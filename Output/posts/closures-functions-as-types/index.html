<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Inuk Blog"/><link rel="canonical" href="https://www.inuk.blog/posts/closures-functions-as-types"/><meta name="twitter:url" content="https://www.inuk.blog/posts/closures-functions-as-types"/><meta name="og:url" content="https://www.inuk.blog/posts/closures-functions-as-types"/><title>"Closures: Functions as types" | Inuk Blog</title><meta name="twitter:title" content=""Closures: Functions as types" | Inuk Blog"/><meta name="og:title" content=""Closures: Functions as types" | Inuk Blog"/><meta name="description" content="If you've coded Swift for a short while, you may have experienced closures. Here's a short explanation of the concept."/><meta name="twitter:description" content="If you've coded Swift for a short while, you may have experienced closures. Here's a short explanation of the concept."/><meta name="og:description" content="If you've coded Swift for a short while, you may have experienced closures. Here's a short explanation of the concept."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Inuk Blog"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Inuk Blog</a></div></header><div class="wrapper"><article><div class="content"><p>If you've coded Swift for a short while, you may have experienced them. They manifest in a few different but ultimately it's just functions as types and values, and it's pretty cool.</p><p>A short code sample would be something like:</p><pre><code>     <span class="keyword">var</span> closure: () -&gt; ()
</code></pre><p>This is a very simple uninitiated closure, which would look like this as a function:</p><pre><code>     <span class="keyword">func</span> myFunc() 
</code></pre><p>It doesn't take a parameter, and doesn't return one either. There are quite a few great ways to use closures, the one that come to most peoples minds is the following:</p><pre><code>     <span class="keyword">func</span> someFunctionThatTakesAClosure(closure: (<span class="type">String</span>) -&gt; (<span class="type">Int</span>)) {
    	<span class="call">print</span>(<span class="call">closure</span>(<span class="string">"Hello World"</span>)) <span class="comment">// prints whatever number the closure returns</span>
    }
    
    <span class="call">someFunctionThatTakesAClosure</span> { string <span class="keyword">in</span>
    	<span class="call">print</span>(string) <span class="comment">// this prints "Hello World"</span>
    	<span class="keyword">return</span> string.<span class="property">count</span> <span class="comment">// This will return 11</span>
    }
    
    <span class="keyword">func</span> printAndCount(string: <span class="type">String</span>) -&gt; <span class="type">Int</span> {
    	<span class="call">print</span>(string)
    	<span class="keyword">return</span> string.<span class="property">count</span>
    }
    
    <span class="call">someFunctionThatTakesAClosure</span>(closure: printAndCount) <span class="comment">// you can also pass in functions as long as it matches the closure, e.g. both `closure` and `printAndReturn` takes a String and return and Int</span>
</code></pre><p>Notice the signature of closure, it matches a func almost as if it's an <code>func closure(_:String)-&gt;String</code>. This is the signature that <code>someFunctionThatTakesAClosure</code> expects, and you can pass in anything as long as it matches. the <code>{ string in }</code> captures the parameter, and handles it as the constant <code>string</code>, like if we had the signature <code>(string: String)</code>.</p><p>A different way to handle functions as types would be in types. We can have the type:</p><pre><code>     <span class="keyword">struct</span> Button {
    	<span class="keyword">private(set) var</span> action: () -&gt; ()
    	<span class="keyword">init</span>(action: <span class="keyword">@escaping</span> () -&gt; ()) {
    		<span class="keyword">self</span>.<span class="property">action</span> = action
    	}
    }
</code></pre><p>Note the <code>@escaping</code> in the initialiser, this is because we're saving it so it sticks around after the function returns, which is what is called "escaping" in Swift</p><p>This gives us a type <code>Button</code> where each instance has it's own behavior on <code>action()</code>. The <code>private(set)</code> makes it so that we can't accidentally change a given instance's <code>action</code> property. This follow the same rules as with <code>myFunc</code>, so I can actually instanciate the button and use th property like so</p><pre><code>     <span class="keyword">let</span> printOne = <span class="type">Button</span> { <span class="call">print</span>(<span class="number">1</span>) }
    printOne.<span class="call">action</span>() <span class="comment">// prints 1</span>
</code></pre><p>And if you've played with Vapor for a bit, you might've noticed something. In Vapor we have the function for making get routes look as following</p><pre><code>     <span class="keyword">func</span> get&lt;<span class="type">Response</span>&gt;(<span class="keyword">_</span> path: <span class="type">PathComponent</span>..., use closure: <span class="keyword">@escaping</span> (<span class="type">Request</span>) <span class="keyword">throws</span> -&gt; <span class="type">Response</span>) -&gt; <span class="type">Route</span> <span class="keyword">where</span> <span class="type">Response</span> : <span class="type">ResponseEncodable</span>
</code></pre><p>There's a lot in this function to unwrap. Let's start from an end, the <code>&lt;Response&gt;</code> makes a generic type, which'll be used later. the <code>use closure: @escaping (Request) throws -&gt; Response</code> makes it so that the function can be called as: <code>get("index", use: myRoute)</code>. This function actually saves the closure to a big array behind the scenes, that gets evaluated on route calls, hence the <code>@escape</code>. The return type of the passed in function <em>has</em> to be <code>Response</code> and conform to <code>ResponseEncodable</code> as seen by the <code>where Response : ResponseEncodable</code>.</p><p>So in short, closures is a way to handle functions (and function signatures) as types, and thus pass functions around as you would instances of types. They're powerful, even not used in an asynchronous matter. And if you've used <code>.map</code> you've used closures before.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">swift</a></li><li><a href="/tags/coding">coding</a></li><li><a href="/tags/how-to">how to</a></li></ul></article></div><footer><p>Proudly generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="https://discord.gg/CxPyCCJ">Discord</a> | <a href="/feed.rss">RSS</a></p></footer></body></html>